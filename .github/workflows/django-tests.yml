# .github/workflows/django-tests.yml

name: Django CI

# 1. Controls when the workflow will run
on:
    push:
        branches: ["main"]
    pull_request:
        branches: ["main"]

# 2. A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
    build-and-test:
        # The type of runner that the job will run on
        runs-on: ubuntu-latest

        # 3. Steps represent a sequence of tasks that will be executed as part of the job
        steps:
            # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
            - name: Check out repository code
              uses: actions/checkout@v4

            # Your docker-compose.local.yml likely depends on a .env file.
            # This step creates a .env file for the CI environment from a template.
            # You should create a .env.ci file in your repo with non-secret test values.
            - name: Set up .env file for testing
              run: |
                  echo "SECRET_KEY=ci-secret-key-for-testing" >> .env
                  echo "POSTGRES_DB=testdb" >> .env
                  echo "POSTGRES_USER=testuser" >> .env
                  echo "POSTGRES_PASSWORD=testpass" >> .env
                  echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" >> .env

            # Build and start all the services (web, worker, db, redis) in the background
            - name: Build and start the Docker containers
              run: |
                # Start db and redis first
                docker compose -f docker-compose.local.yml up -d db redis
                # Build the web service
                docker compose -f docker-compose.local.yml build web
                # Start web service with a keep-alive command for testing
                # Note: We need to run the entrypoint (migrations) and then sleep
                docker compose -f docker-compose.local.yml run -d --name bibliotype_web_test --service-ports web sh -c "./wait-for-postgres.sh db && poetry run python manage.py migrate && exec sleep infinity"

            # A crucial step. Even after 'up' completes, the database might need a few seconds
            # to initialize fully. This pause prevents tests from failing by trying to connect too early.
            - name: Wait for database to be ready
              run: sleep 10

            # Check that the container is running
            - name: Verify web container is running
              run: |
                docker ps | grep bibliotype_web_test || docker ps -a | grep bibliotype_web_test
            
            # Run the test suite using the exact command that works locally
            - name: Run tests
              run: docker exec bibliotype_web_test poetry run python manage.py test

            # Optional but good practice: This step will run even if the tests fail.
            - name: Tear down containers
              if: always()
              run: |
                docker stop bibliotype_web_test || true
                docker rm bibliotype_web_test || true
                docker compose -f docker-compose.local.yml down
