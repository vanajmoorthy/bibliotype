# .github/workflows/django-tests.yml

name: Django CI

# 1. Controls when the workflow will run
on:
    push:
        branches: ["main"]
    pull_request:
        branches: ["main"]

# 2. A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
    build-and-test:
        # The type of runner that the job will run on
        runs-on: ubuntu-latest

        # 3. Steps represent a sequence of tasks that will be executed as part of the job
        steps:
            # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
            - name: Check out repository code
              uses: actions/checkout@v4

            # Your docker-compose.local.yml likely depends on a .env file.
            # This step creates a .env file for the CI environment from a template.
            # You should create a .env.ci file in your repo with non-secret test values.
            - name: Set up .env file for testing
              run: |
                  echo "SECRET_KEY=ci-secret-key-for-testing" >> .env
                  echo "POSTGRES_DB=testdb" >> .env
                  echo "POSTGRES_USER=testuser" >> .env
                  echo "POSTGRES_PASSWORD=testpass" >> .env
                  echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" >> .env

            # Build and start all the services (web, worker, db, redis) in the background
            - name: Build and start the Docker containers
              run: |
                # Start db and redis first
                docker compose -f docker-compose.local.yml up -d db redis
                # Wait for database to be healthy
                timeout 60 bash -c 'until docker compose -f docker-compose.local.yml exec -T db pg_isready -U testuser -d testdb; do sleep 2; done'
                # Build the web service
                docker compose -f docker-compose.local.yml build web
                # Start web service - the entrypoint will handle migrations, then we keep it alive
                docker compose -f docker-compose.local.yml run -d --name bibliotype_web_test --service-ports --rm=false web sleep infinity

            # Wait for the container to be ready and migrations to complete
            - name: Wait for web container to be ready
              run: |
                # Wait for container to be running
                for i in {1..30}; do
                  if docker ps --format '{{.Names}}' | grep -q bibliotype_web_test; then
                    echo "Container is running"
                    break
                  fi
                  echo "Waiting for container to start... ($i/30)"
                  sleep 2
                done
                
                # Wait for migrations to complete by checking logs
                echo "Waiting for migrations to complete..."
                sleep 5
                
                # Show container status
                docker ps -a | grep bibliotype_web_test || true
                
                # Show logs if container is not running
                if ! docker ps --format '{{.Names}}' | grep -q bibliotype_web_test; then
                  echo "Container exited, showing logs:"
                  docker logs bibliotype_web_test || true
                  exit 1
                fi
            
            # Run the test suite using the exact command that works locally
            - name: Run tests
              run: docker exec bibliotype_web_test poetry run python manage.py test

            # Optional but good practice: This step will run even if the tests fail.
            - name: Tear down containers
              if: always()
              run: |
                docker stop bibliotype_web_test || true
                docker rm bibliotype_web_test || true
                docker compose -f docker-compose.local.yml down
